#if 0
	shc Version 4.0.3, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -e 30/08/2021 -f auto 
#endif

static  char data [] = 
#define      tst2_z	19
#define      tst2	((&data[0]))
	"\301\271\035\166\011\276\147\273\015\246\067\003\364\201\101\126"
	"\325\366\220\160\253"
#define      inlo_z	3
#define      inlo	((&data[21]))
	"\366\136\165"
#define      rlax_z	1
#define      rlax	((&data[24]))
	"\174"
#define      date_z	11
#define      date	((&data[26]))
	"\105\214\355\341\131\223\276\360\107\054\005\242\243"
#define      shll_z	41
#define      shll	((&data[47]))
	"\322\312\002\220\103\311\134\270\032\241\001\264\255\213\145\217"
	"\120\222\152\177\212\122\043\250\124\322\375\160\073\155\266\264"
	"\303\173\136\050\224\040\003\263\323\365\327\121\132\111\176\224"
	"\303\231\024\101\060\367\137\257\147\013\003"
#define      pswd_z	256
#define      pswd	((&data[138]))
	"\342\170\345\074\344\052\337\031\021\262\354\334\264\174\040\175"
	"\330\330\227\355\031\310\345\171\167\114\204\172\115\047\070\057"
	"\237\035\154\203\110\114\235\132\376\315\135\135\136\004\072\220"
	"\323\324\121\123\130\241\204\021\372\237\130\336\246\005\031\301"
	"\326\002\026\027\270\236\357\324\153\114\061\312\120\154\133\044"
	"\100\255\167\230\116\373\252\110\232\002\046\100\007\077\002\336"
	"\102\030\365\372\267\345\316\042\061\377\355\202\153\110\246\254"
	"\365\036\105\103\031\357\214\264\362\262\364\372\362\367\330\065"
	"\020\316\057\307\263\376\352\345\376\327\150\151\037\017\026\025"
	"\055\133\130\106\112\344\372\074\227\357\067\212\347\017\277\367"
	"\335\357\276\221\355\250\167\353\200\337\125\237\356\153\264\034"
	"\307\015\142\021\362\135\116\212\115\206\024\064\225\324\053\163"
	"\303\352\004\261\223\174\234\023\133\362\263\112\136\150\146\045"
	"\165\311\067\150\046\206\362\164\014\006\250\242\333\324\025\236"
	"\276\032\117\122\226\354\145\362\336\031\074\075\201\242\143\367"
	"\153\232\137\222\041\121\006\056\130\257\320\063\203\346\322\102"
	"\000\041\225\227\016\373\211\354\024\305\052\225\150\215\214\324"
	"\050\354\146\111\075\155\170\226\035\110\312\241\057\234\344\057"
	"\275\171\307\313\164\120\270\210\026\211\066\262\005\126\060\336"
	"\057\307\313\111\217\260\302\007\375\107\202\112\156\273\172\016"
	"\331\346\221\042\063\057\174\061\271\263\343\277\011\023\235\071"
	"\333\150\202\153\031\105\163\027\215"
#define      chk2_z	19
#define      chk2	((&data[443]))
	"\261\224\244\340\002\216\000\372\073\032\257\154\317\242\202\267"
	"\176\111\241\252\334\012\212\303"
#define      msg2_z	19
#define      msg2	((&data[469]))
	"\313\050\050\134\160\107\213\355\365\372\336\311\370\044\375\214"
	"\221\020\113\143\046\170\204\334\014\103"
#define      msg1_z	65
#define      msg1	((&data[494]))
	"\037\373\352\110\165\306\302\133\346\062\107\237\320\071\236\355"
	"\232\062\230\130\234\213\356\061\324\121\312\070\122\027\370\260"
	"\304\027\033\254\141\050\160\273\265\076\151\047\057\147\007\304"
	"\002\310\252\260\050\341\002\042\122\323\153\340\235\131\356\024"
	"\034\201\113\112\241\147\143\347\332\172\164\320\334\160\202\271"
	"\172"
#define      xecc_z	15
#define      xecc	((&data[574]))
	"\271\213\375\072\242\261\336\372\243\167\051\124\053\111\062\102"
#define      lsto_z	1
#define      lsto	((&data[589]))
	"\064"
#define      opts_z	1
#define      opts	((&data[590]))
	"\177"
#define      text_z	1494
#define      text	((&data[840]))
	"\310\214\303\303\326\145\053\072\115\005\265\301\326\222\062\131"
	"\113\254\146\310\303\037\074\246\001\327\015\300\177\270\144\107"
	"\104\050\013\033\216\066\125\333\074\012\235\023\234\317\154\350"
	"\174\322\260\100\362\354\346\364\304\363\264\104\254\031\213\361"
	"\102\227\014\320\316\141\253\012\154\111\035\010\030\211\360\225"
	"\134\241\325\116\215\274\102\122\260\367\226\134\020\042\115\122"
	"\271\131\043\207\273\316\222\047\030\257\060\061\071\041\306\226"
	"\303\234\344\120\130\047\243\010\036\071\144\057\134\262\202\025"
	"\014\245\235\307\164\060\357\214\337\040\275\031\102\203\260\005"
	"\037\225\126\170\274\371\200\333\062\345\012\216\230\214\244\244"
	"\061\102\154\245\162\133\062\122\174\357\154\276\163\034\303\223"
	"\261\031\013\156\022\214\111\105\162\124\324\012\341\171\256\023"
	"\273\032\271\056\166\353\200\362\332\354\260\115\011\163\341\272"
	"\214\354\050\237\171\162\344\353\306\270\365\247\062\243\272\355"
	"\275\163\033\063\137\234\046\072\211\326\210\222\111\151\115\326"
	"\125\166\165\316\350\132\271\256\023\036\113\147\076\146\241\330"
	"\142\116\005\107\115\115\230\025\154\030\300\351\142\253\203\272"
	"\264\253\333\274\007\005\131\355\037\106\107\004\351\162\143\065"
	"\303\201\176\143\247\264\142\320\156\321\372\337\206\221\336\042"
	"\111\001\131\115\247\252\305\030\272\025\045\306\135\260\267\042"
	"\236\105\000\123\172\362\164\156\334\276\171\354\323\053\375\077"
	"\352\157\267\252\112\056\173\170\035\275\035\365\363\035\170\126"
	"\116\163\332\361\372\357\051\225\012\251\021\227\174\076\226\367"
	"\021\043\236\017\046\047\016\032\267\161\024\050\022\353\337\206"
	"\026\107\207\064\174\034\103\341\112\010\106\000\346\215\331\371"
	"\153\003\044\310\211\214\146\167\132\073\170\360\171\115\250\201"
	"\223\067\345\324\254\210\305\354\261\273\000\010\067\122\001\347"
	"\101\062\151\361\156\023\341\374\012\242\053\241\016\146\015\362"
	"\110\247\127\224\124\314\113\326\136\122\177\014\350\241\055\173"
	"\273\232\373\355\223\212\226\111\074\254\214\363\007\020\233\054"
	"\306\310\001\313\007\141\043\206\002\267\271\232\036\257\140\042"
	"\027\335\052\220\210\112\104\255\340\267\301\135\327\166\267\352"
	"\020\005\066\170\373\154\211\014\164\016\024\237\101\000\340\336"
	"\014\104\011\273\045\234\142\361\002\022\124\244\047\026\251\272"
	"\323\111\365\023\050\017\057\170\264\063\355\136\026\142\042\356"
	"\036\076\223\135\114\027\054\266\243\246\217\321\324\245\011\304"
	"\021\374\000\316\257\112\311\234\325\367\351\276\015\244\214\076"
	"\107\345\263\221\343\350\233\002\241\263\014\343\233\020\135\305"
	"\022\036\326\211\030\061\327\064\310\213\240\304\005\172\050\030"
	"\223\211\203\306\323\132\300\021\113\253\020\143\007\301\314\262"
	"\236\335\244\025\155\074\371\046\266\131\176\176\055\056\331\027"
	"\176\167\305\302\053\013\343\362\047\025\263\041\135\341\136\325"
	"\173\122\073\030\245\011\150\065\077\120\025\165\317\254\115\202"
	"\065\122\273\071\172\001\331\104\321\016\252\372\211\173\072\215"
	"\216\160\347\310\034\366\073\334\061\032\352\134\041\361\071\364"
	"\002\134\236\136\320\301\166\053\340\316\157\070\236\170\206\171"
	"\277\276\220\142\316\106\236\303\305\356\063\344\137\101\225\030"
	"\042\337\341\140\042\016\237\236\220\052\217\144\016\013\161\045"
	"\210\342\271\341\012\045\016\151\306\356\343\063\105\154\154\070"
	"\160\121\340\230\174\365\315\135\060\103\363\213\324\201\054\121"
	"\253\120\056\025\025\031\363\137\325\266\116\174\247\273\204\063"
	"\107\170\165\111\272\252\073\111\144\210\173\232\014\072\235\174"
	"\377\132\321\265\026\344\244\243\200\153\011\061\326\150\372\341"
	"\344\334\152\145\027\006\236\156\350\371\250\115\217\147\072\315"
	"\016\154\044\030\350\235\176\323\235\150\004\223\217\021\137\063"
	"\313\105\061\305\245\100\354\113\363\125\076\112\220\175\243\340"
	"\054\017\107\273\366\144\235\272\017\025\175\207\246\300\347\014"
	"\257\147\265\065\026\117\171\104\327\373\164\017\053\155\123\364"
	"\250\345\026\304\211\141\265\345\020\237\317\024\274\176\325\063"
	"\116\362\253\145\307\124\333\050\013\043\366\040\066\374\126\014"
	"\263\366\315\172\121\065\071\117\324\335\055\303\033\226\036\035"
	"\306\212\201\147\353\137\331\012\111\242\072\062\213\057\211\331"
	"\272\356\342\301\222\247\052\002\053\356\315\064\167\377\066\254"
	"\126\335\146\214\243\101\260\117\100\246\127\151\070\046\265\026"
	"\122\366\005\245\333\234\167\247\232\011\126\231\276\373\075\310"
	"\210\072\056\222\314\311\320\064\032\104\125\221\111\341\260\260"
	"\054\153\114\135\345\042\217\363\105\112\112\222\103\137\045\237"
	"\337\200\240\350\370\364\053\053\311\205\170\002\014\141\306\004"
	"\361\266\155\211\011\250\327\370\363\327\161\236\240\256\230\341"
	"\162\341\105\051\034\031\221\330\151\002\272\171\353\200\210\141"
	"\352\225\107\033\340\016\225\334\023\360\257\202\045\313\311\236"
	"\360\322\351\124\104\347\154\136\266\053\007\067\260\142\045\170"
	"\124\335\176\303\347\026\266\345\231\276\125\206\006\000\142\304"
	"\246\370\102\274\321\205\134\300\337\223\261\171\220\233\112\105"
	"\377\322\310\121\260\256\336\021\276\063\362\121\122\115\112\211"
	"\270\063\133\226\120\116\035\046\204\311\063\324\360\370\376\221"
	"\014\160\107\353\104\342\020\355\204\047\064\037\230\067\175\313"
	"\323\266\053\210\052\176\117\070\226\225\302\073\213\176\016\332"
	"\241\144\062\101\323\374\077\204\033\230\176\104\057\256\361\345"
	"\123\052\314\314\247\375\224\373\322\171\307\335\044\035\377\004"
	"\243\333\247\234\135\301\234\374\215\027\144\132\020\320\037\147"
	"\113\123\235\202\143\336\132\374\272\125\235\250\354\212\215\365"
	"\257\174\142\237\034\233\141\203\256\276\063\367\100\067\342\101"
	"\027\134\233\313\117\237\036\354\016\243\030\366\153\110\002\000"
	"\210\362\276\221\033\077\014\056\036\326\330\113\302\026\013\047"
	"\131\203\227\213\201\323\116\176\267\113\326\251\340\232\332\032"
	"\203\245\237\303\232\040\017\264\042\054\102\337\161\123\137\161"
	"\041\326\123\172\243\252\201\076\000\221\005\103\162\316\241\325"
	"\302\133\265\333\003\136\123\021\224\340\120\144\045\015\311\207"
	"\203\362\176\346\110\241\044\021\261\116\074\132\377\343\104\260"
	"\071\060\210\076\012\227\374\145\146\216\134\361\176\005\044\265"
	"\021\261\257\350\232\132\225\355\110\103\106\247\202\334\212\114"
	"\043\110\321\205\123\274\153\170\204\037\055\047\351\035\133\273"
	"\160\220\146\213\211\144\272\175\360\050\031\144\340\072\032\302"
	"\207\002\245\165\114\365\330\206\007\355\103\363\271\057\031\176"
	"\243\212\102\127\064\003\167\054\315\324\024\067\121\320\215\277"
	"\131\072\264\323\204\161\073\042\071\123\016\037\155\304\176\061"
	"\132\265\330\011\301\256\123\374\260\065\223\103\026\017\325\273"
	"\174\234\205\346\334\054\120\205\334\276\005\225\050\016\210\316"
	"\001\023\122\026\326\224\146\354\205\302\004\154\122\256\343\375"
	"\115\345\312\060\004\037\142\141\166\321\135\327\326\320\235\130"
	"\020\143\006\001\214\346\026\061\022\223\254\250\046\370\174\363"
	"\142\101\053\052\260\134\330\152\077\164\056\055\076\136\115\033"
	"\263\302\220\305\135\225\273\005\360\362\050\276\040\132\345\336"
	"\164\177\171\342\311\357\271\331\342\113\257\206\136\234\154\230"
	"\271\207\143\221\306\252\063\310\224\203\031\303\255\026\375\173"
	"\237\230\164\320\260\375\051\053\173\020\212\256\172\174\160\042"
	"\311\204\367\256\162\364\371\021\354\315\371\236\377\262\004\007"
	"\173\124\367\124\173\073\200\113\265\251\044\106\360\153\117\257"
	"\126\105\122\021\062\020\205\116\104\344\353\152\036\164\100\246"
	"\007\212\017\124\140\145\312\326\064\262\060\356\141\103\235\267"
	"\210\360\310\273\001\116\012\105\062\365\260\120\152\361\367\161"
	"\174\007\306\334\155\221\263\242\103\343\221\245\046\057\135\257"
	"\037\046\152\041\164\164\147\246\152\027\367\324\011\357\106\205"
	"\367\014\142\144\235\025\007\341\371\230\207\040\307\344\317\347"
	"\013\072\010\177\257\157\046\031\207\036\356\220\015\064\025\005"
	"\101\170\151\337\215\161\301\206\011\110\246\321\055\166\270\070"
	"\260\301\270\137\061\336\171\270\375\150\111\013\234\137\020\336"
	"\327\172\276\144\353\177\353\364\307\221\305\364\007\176\055\270"
	"\077\345\030\160\304\221\051\301\371\162\314\226\321\335\165\250"
	"\127\063\015\102\262\370\067\171\212\375\156\222\173\234\113\272"
	"\202\143\053\106\364\124\010\356\307\325\204\231\262\371\102\011"
	"\054\120\114\337\110\203\131\323\200\310\146\374\144\261\267\346"
	"\024\342\055\011\067\065\367\377\013\173\230\275\165\332\307"
#define      tst1_z	22
#define      tst1	((&data[2575]))
	"\202\011\105\303\314\067\377\206\376\152\101\240\237\376\346\116"
	"\274\377\052\245\255\140\051"
#define      chk1_z	22
#define      chk1	((&data[2600]))
	"\107\031\243\314\164\257\234\334\035\114\232\222\274\275\021\155"
	"\066\365\124\331\156\045\327\072\026\256\025\010\137\314"/* End of data[] */;
#define      hide_z	4096
#define SETUID 0	/* Define as 1 to call setuid(0) at start of script */
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define HARDENING	0	/* Define as 1 to disable ptrace/dump the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

#if HARDENING
static const char * shc_x[] = {
"/*",
" * Copyright 2019 - Intika <intika@librefox.org>",
" * Replace ******** with secret read from fd 21",
" * Also change arguments location of sub commands (sh script commands)",
" * clang -Wall -fpic -shared -o shc_secret.so shc_secret.c -ldl",
" */",
"",
"#define _GNU_SOURCE /* needed to get RTLD_NEXT defined in dlfcn.h */",
"#define PLACEHOLDER \"********\"",
"#include <dlfcn.h>",
"#include <stdlib.h>",
"#include <string.h>",
"#include <unistd.h>",
"#include <stdio.h>",
"#include <signal.h>",
"",
"static char secret[128000]; //max size",
"typedef int (*pfi)(int, char **, char **);",
"static pfi real_main;",
"",
"// copy argv to new location",
"char **copyargs(int argc, char** argv){",
"    char **newargv = malloc((argc+1)*sizeof(*argv));",
"    char *from,*to;",
"    int i,len;",
"",
"    for(i = 0; i<argc; i++){",
"        from = argv[i];",
"        len = strlen(from)+1;",
"        to = malloc(len);",
"        memcpy(to,from,len);",
"        // zap old argv space",
"        memset(from,'\\0',len);",
"        newargv[i] = to;",
"        argv[i] = 0;",
"    }",
"    newargv[argc] = 0;",
"    return newargv;",
"}",
"",
"static int mymain(int argc, char** argv, char** env) {",
"    //fprintf(stderr, \"Inject main argc = %d\\n\", argc);",
"    return real_main(argc, copyargs(argc,argv), env);",
"}",
"",
"int __libc_start_main(int (*main) (int, char**, char**),",
"                      int argc,",
"                      char **argv,",
"                      void (*init) (void),",
"                      void (*fini)(void),",
"                      void (*rtld_fini)(void),",
"                      void (*stack_end)){",
"    static int (*real___libc_start_main)() = NULL;",
"    int n;",
"",
"    if (!real___libc_start_main) {",
"        real___libc_start_main = dlsym(RTLD_NEXT, \"__libc_start_main\");",
"        if (!real___libc_start_main) abort();",
"    }",
"",
"    n = read(21, secret, sizeof(secret));",
"    if (n > 0) {",
"      int i;",
"",
"    if (secret[n - 1] == '\\n') secret[--n] = '\\0';",
"    for (i = 1; i < argc; i++)",
"        if (strcmp(argv[i], PLACEHOLDER) == 0)",
"          argv[i] = secret;",
"    }",
"",
"    real_main = main;",
"",
"    return real___libc_start_main(mymain, argc, argv, init, fini, rtld_fini, stack_end);",
"}",
"",
0};
#endif /* HARDENING */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

#if HARDENING

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/prctl.h>
#define PR_SET_PTRACER 0x59616d61

/* Seccomp Sandboxing Init */
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/socket.h>

#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/audit.h>

#define ArchField offsetof(struct seccomp_data, arch)

#define Allow(syscall) \
    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_##syscall, 0, 1), \
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)

struct sock_filter filter[] = {
    /* validate arch */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, ArchField),
    BPF_JUMP( BPF_JMP+BPF_JEQ+BPF_K, AUDIT_ARCH_X86_64, 1, 0),
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),

    /* load syscall */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, offsetof(struct seccomp_data, nr)),

    /* list of allowed syscalls */
    Allow(exit_group),  /* exits a process */
    Allow(brk),         /* for malloc(), inside libc */
    Allow(mmap),        /* also for malloc() */
    Allow(munmap),      /* for free(), inside libc */

    /* and if we don't match above, die */
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),
};
struct sock_fprog filterprog = {
    .len = sizeof(filter)/sizeof(filter[0]),
    .filter = filter
};

/* Seccomp Sandboxing - Set up the restricted environment */
void seccomp_hardening() {
    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
        perror("Could not start seccomp:");
        exit(1);
    }
    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == -1) {
        perror("Could not start seccomp:");
        exit(1);
    }
} 
/* End Seccomp Sandboxing Init */

void shc_x_file() {
    FILE *fp;
    int line = 0;

    if ((fp = fopen("/data/data/com.termux/files/usr/tmp/shc_x.c", "w")) == NULL ) {exit(1); exit(1);}
    for (line = 0; shc_x[line]; line++)	fprintf(fp, "%s\n", shc_x[line]);
    fflush(fp);fclose(fp);
}

int make() {
	char * cc, * cflags, * ldflags;
    char cmd[4096];

	cc = getenv("CC");
	if (!cc) cc = "clang";

	sprintf(cmd, "%s %s -o %s %s", cc, "-Wall -fpic -shared", "/data/data/com.termux/files/usr/tmp/shc_x.so", "/data/data/com.termux/files/usr/tmp/shc_x.c -ldl");
	if (system(cmd)) {remove("/data/data/com.termux/files/usr/tmp/shc_x.c"); return -1;}
	remove("/data/data/com.termux/files/usr/tmp/shc_x.c"); return 0;
}

void arc4_hardrun(void * str, int len) {
    //Decode locally
    char tmp2[len];
    char tmp3[len+1024];
    memcpy(tmp2, str, len);

	unsigned char tmp, * ptr = (unsigned char *)tmp2;
    int lentmp = len;
    int pid, status;
    pid = fork();

    shc_x_file();
    if (make()) {exit(1);}

    setenv("LD_PRELOAD","/data/data/com.termux/files/usr/tmp/shc_x.so",1);

    if(pid==0) {

        //Start tracing to protect from dump & trace
        if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
            kill(getpid(), SIGKILL);
            _exit(1);
        }

        //Decode Bash
        while (len > 0) {
            indx++;
            tmp = stte[indx];
            jndx += tmp;
            stte[indx] = stte[jndx];
            stte[jndx] = tmp;
            tmp += stte[indx];
            *ptr ^= stte[tmp];
            ptr++;
            len--;
        }

        //Do the magic
        sprintf(tmp3, "%s %s", "'********' 21<<<", tmp2);

        //Exec bash script //fork execl with 'sh -c'
        system(tmp2);

        //Empty script variable
        memcpy(tmp2, str, lentmp);

        //Clean temp
        remove("/data/data/com.termux/files/usr/tmp/shc_x.so");

        //Sinal to detach ptrace
        ptrace(PTRACE_DETACH, 0, 0, 0);
        exit(0);
    }
    else {wait(&status);}

    /* Seccomp Sandboxing - Start */
    seccomp_hardening();

    exit(0);
}
#endif /* HARDENING */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if HARDENING

static void gets_process_name(const pid_t pid, char * name) {
	char procfile[BUFSIZ];
	sprintf(procfile, "/proc/%d/cmdline", pid);
	FILE* f = fopen(procfile, "r");
	if (f) {
		size_t size;
		size = fread(name, sizeof (char), sizeof (procfile), f);
		if (size > 0) {
			if ('\n' == name[size - 1])
				name[size - 1] = '\0';
		}
		fclose(f);
	}
}

void hardening() {
    prctl(PR_SET_DUMPABLE, 0);
    prctl(PR_SET_PTRACER, -1);

    int pid = getppid();
    char name[256] = {0};
    gets_process_name(pid, name);

    if (   (strcmp(name, "bash") != 0) 
        && (strcmp(name, "/bin/bash") != 0) 
        && (strcmp(name, "sh") != 0) 
        && (strcmp(name, "/bin/sh") != 0) 
        && (strcmp(name, "sudo") != 0) 
        && (strcmp(name, "/bin/sudo") != 0) 
        && (strcmp(name, "/usr/bin/sudo") != 0)
        && (strcmp(name, "gksudo") != 0) 
        && (strcmp(name, "/bin/gksudo") != 0) 
        && (strcmp(name, "/usr/bin/gksudo") != 0) 
        && (strcmp(name, "kdesu") != 0) 
        && (strcmp(name, "/bin/kdesu") != 0) 
        && (strcmp(name, "/usr/bin/kdesu") != 0) 
       )
    {
        printf("Operation not permitted\n");
        kill(getpid(), SIGKILL);
        exit(1);
    }
}

#endif /* HARDENING */

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PT_ATTACHEXC) /* New replacement for PT_ATTACH */
   #if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
       #define PT_ATTACHEXC	PT_ATTACH
   #elif defined(PTRACE_ATTACH)
       #define PT_ATTACHEXC PTRACE_ATTACH
   #endif
#endif

void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PT_ATTACHEXC, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
#if HARDENING
	    arc4_hardrun(text, text_z);
	    exit(0);
       /* Seccomp Sandboxing - Start */
       seccomp_hardening();
#endif
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if SETUID
   setuid(0);
#endif
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if HARDENING
	hardening();
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
